package com.example.dfs;

/**
 * <p>L924:尽量减少恶意软件的传播</p>
 * @author zhenwu
 * @date 2025/8/4 21:59
 */
public class L924_MinMalwareSpread {
    public static void main(String[] args) {

    }

    /**
     * 思路：寻找只有一个感染节点的最大连通分量
     * 时间复杂度：O(n^2)
     * 空间复杂度：O(n)
     */
    private static int minMalwareSpread(int[][] graph, int[] initial) {
        boolean[] isInitial = new boolean[graph.length];
        int minIdx = Integer.MAX_VALUE;
        for (int x : initial) {
            isInitial[x] = true;
            minIdx = Math.min(minIdx, x);
        }

        int ans = -1, maxSize = 0;
        boolean[] visited = new boolean[graph.length];
        for (int x : initial) {
            if (visited[x]) {
                continue;
            }
            nodeState = -1;
            size = 0;
            dfs(x, graph, isInitial, visited);
            if (nodeState >= 0 && (size > maxSize || (size == maxSize && nodeState < ans))) {
                ans = x;
                maxSize = size;
            }
        }
        return ans == -1 ? minIdx : ans;
    }

    static int nodeState, size;

    private static void dfs(int x, int[][] graph, boolean[] isInitial, boolean[] visited) {
        visited[x] = true;
        size++;
        if (nodeState != -2 && isInitial[x]) {
            // nodeState最终大于等于0，则证明此连通分量中只有一个感染节点，反之，则此连通分量有多个感染节点
            nodeState = nodeState == -1 ? x : -2;
        }
        for (int y = 0, len = graph[x].length; y < len; y++) {
            if (graph[x][y] == 1 && !visited[y]) {
                dfs(y, graph, isInitial, visited);
            }
        }
    }
}
